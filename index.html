<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IDIOMATOR - Language Learning</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #e6e6e6;
            min-height: 100vh;
            padding: 10px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 15px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }
        
        /* Header */
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #0f3460;
        }
        
        .logo {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .logo h1 {
            font-size: 28px;
            background: linear-gradient(90deg, #4cc9f0, #4361ee);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            font-weight: 700;
        }
        
        .logo-icon {
            font-size: 32px;
            color: #4cc9f0;
        }
        
        .stats {
            display: flex;
            gap: 15px;
            font-size: 18px;
        }
        
        .stat-box {
            background-color: rgba(15, 52, 96, 0.7);
            padding: 8px 15px;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 100px;
        }
        
        .stat-value {
            font-size: 22px;
            font-weight: 700;
            color: #4cc9f0;
        }
        
        .stat-label {
            font-size: 12px;
            color: #a0a0c0;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        /* Controls */
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-bottom: 25px;
            background-color: rgba(15, 52, 96, 0.3);
            padding: 15px;
            border-radius: 10px;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
        }
        
        .control-label {
            font-size: 14px;
            margin-bottom: 8px;
            color: #a0a0c0;
            font-weight: 500;
        }
        
        select {
            padding: 12px 15px;
            background-color: rgba(30, 30, 60, 0.8);
            border: 1px solid #0f3460;
            border-radius: 8px;
            color: #e6e6e6;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
            appearance: none;
            background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%234cc9f0' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
            background-repeat: no-repeat;
            background-position: right 15px center;
            background-size: 16px;
            padding-right: 40px;
        }
        
        select:hover {
            border-color: #4cc9f0;
            background-color: rgba(30, 30, 80, 0.9);
        }
        
        select:focus {
            outline: none;
            border-color: #4cc9f0;
            box-shadow: 0 0 0 2px rgba(76, 201, 240, 0.2);
        }
        
        /* Concept Display */
        .concept-display-container {
            display: flex;
            gap: 30px;
            margin-bottom: 25px;
            background-color: rgba(15, 52, 96, 0.3);
            padding: 30px 20px;
            border-radius: 12px;
            min-height: 350px;
            align-items: center;
        }
        
        .concept-main {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 290px;
            width: 100%;
            text-align: center;
        }
        
        .answer-sidebar {
            width: 300px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border-left: 2px solid rgba(15, 52, 96, 0.7);
            padding-left: 30px;
            min-height: 290px;
        }
        
        .concept-icon {
            font-size: 80px;
            margin-bottom: 20px;
            filter: drop-shadow(0 0 8px rgba(76, 201, 240, 0.5));
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
        }
        
        .concept-type {
            display: inline-block;
            padding: 6px 15px;
            background-color: rgba(67, 97, 238, 0.3);
            border-radius: 20px;
            font-size: 14px;
            color: #a0a0c0;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .concept-word {
            font-size: 48px;
            font-weight: 700;
            margin-bottom: 10px;
            text-align: center;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
        }
        
        .concept-phonetic {
            font-size: 24px;
            color: #a0a0c0;
            margin-bottom: 10px;
            font-style: italic;
            text-align: center;
            width: 100%;
        }
        
        .conjugation-display {
            display: flex;
            gap: 10px;
            margin-top: 10px;
            min-height: 40px;
            align-items: center;
            justify-content: center;
            flex-wrap: wrap;
            width: 100%;
        }
        
        .conjugation-tag {
            display: inline-block;
            padding: 6px 15px;
            background-color: rgba(114, 9, 183, 0.3);
            border: 1px solid #7209b7;
            border-radius: 20px;
            font-size: 14px;
            color: #e6e6e6;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 500;
        }
        
        .answer-label {
            font-size: 16px;
            color: #a0a0c0;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .answer-hidden {
            font-size: 20px;
            color: #a0a0c0;
            font-style: italic;
            margin-bottom: 20px;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 50px;
        }
        
        .answer-word {
            font-size: 36px;
            color: #4cc9f0;
            font-weight: 600;
            margin-bottom: 10px;
            text-align: center;
            min-height: 50px;
            display: flex;
            align-items: center;
            display: none; /* Hidden by default */
        }
        
        .answer-phonetic {
            font-size: 20px;
            color: #a0a0c0;
            font-style: italic;
            margin-bottom: 15px;
            display: none; /* Hidden by default */
        }
        
        .answer-feedback {
            font-size: 18px;
            text-align: center;
            min-height: 30px;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .answer-feedback.correct {
            color: #2a9d8f;
        }
        
        .answer-feedback.incorrect {
            color: #e63946;
        }
        
        /* Action Section */
        .action-section {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 15px;
        }
        
        .guess-section {
            display: flex;
            gap: 10px;
            grid-column: span 2;
        }
        
        .guess-input {
            flex: 1;
            padding: 15px;
            background-color: rgba(30, 30, 60, 0.8);
            border: 2px solid #0f3460;
            border-radius: 8px;
            color: #e6e6e6;
            font-size: 18px;
        }
        
        .guess-input:focus {
            outline: none;
            border-color: #4cc9f0;
        }
        
        .send-btn {
            background-color: #4361ee;
            color: white;
            border: none;
            border-radius: 8px;
            padding: 0 25px;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        
        .send-btn:hover {
            background-color: #5a75f0;
        }
        
        .action-btn {
            padding: 18px 10px;
            border: none;
            border-radius: 10px;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }
        
        .tell-btn {
            background-color: #e63946;
            color: white;
        }
        
        .tell-btn:hover {
            background-color: #f5606d;
            transform: translateY(-3px);
        }
        
        .next-btn {
            background-color: #2a9d8f;
            color: white;
        }
        
        .next-btn:hover {
            background-color: #3dbdaa;
            transform: translateY(-3px);
        }
        
        /* Conjugate Button */
        .conjugate-btn {
            background-color: #7209b7;
            color: white;
            border: none;
            border-radius: 8px;
            padding: 15px;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.3s;
            width: 100%;
            margin-bottom: 25px;
        }
        
        .conjugate-btn:hover {
            background-color: #9d4edd;
        }
        
        .conjugate-btn.conjugating {
            background-color: #e63946;
        }
        
        /* Loading Indicator */
        .loading {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 300px;
            color: #4cc9f0;
            font-size: 18px;
            width: 100%;
        }
        
        .loading-spinner {
            border: 4px solid rgba(76, 201, 240, 0.3);
            border-top: 4px solid #4cc9f0;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin-bottom: 15px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Footer */
        .footer {
            text-align: center;
            padding-top: 20px;
            border-top: 1px solid #0f3460;
            color: #a0a0c0;
            font-size: 14px;
        }
        
        /* Mode Indicator */
        .mode-indicator {
            display: inline-block;
            padding: 4px 10px;
            background-color: rgba(67, 97, 238, 0.3);
            border-radius: 12px;
            font-size: 12px;
            margin-top: 5px;
            color: #a0a0c0;
        }
        
        /* Error Message */
        .error-message {
            color: #e63946;
            text-align: center;
            padding: 20px;
            background-color: rgba(230, 57, 70, 0.1);
            border-radius: 8px;
            margin-bottom: 20px;
        }
        
        /* Responsive */
        @media (max-width: 992px) {
            .concept-display-container {
                flex-direction: column;
                gap: 20px;
            }
            
            .answer-sidebar {
                width: 100%;
                border-left: none;
                border-top: 2px solid rgba(15, 52, 96, 0.7);
                padding-left: 0;
                padding-top: 30px;
                min-height: auto;
            }
        }
        
        @media (max-width: 768px) {
            .header {
                flex-direction: column;
                gap: 15px;
            }
            
            .concept-word {
                font-size: 36px;
            }
            
            .answer-word {
                font-size: 28px;
            }
            
            .concept-icon {
                font-size: 60px;
            }
            
            .action-section {
                grid-template-columns: 1fr;
            }
            
            .guess-section {
                grid-column: span 1;
            }
            
            .controls {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <div class="logo">
                <div class="logo-icon"><i class="fas fa-language"></i></div>
                <h1>IDIOMATOR</h1>
            </div>
            <div class="stats">
                <div class="stat-box">
                    <div class="stat-value" id="correct-count">0</div>
                    <div class="stat-label">Correct</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="total-count">0</div>
                    <div class="stat-label">Total</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="accuracy">0%</div>
                    <div class="stat-label">Accuracy</div>
                </div>
            </div>
        </div>
        
        <!-- Controls -->
        <div class="controls">
            <div class="control-group">
                <div class="control-label">Language to Learn</div>
                <select id="target-language">
                    <option value="en">English</option>
                    <option value="es">Spanish</option>
                    <option value="ka">Georgian</option>
                </select>
            </div>
            
            <div class="control-group">
                <div class="control-label">Reference Language</div>
                <select id="reference-language">
                    <option value="en">English</option>
                    <option value="es">Spanish</option>
                    <option value="ka">Georgian</option>
                </select>
            </div>
            
            <div class="control-group">
                <div class="control-label">Interaction Style</div>
                <select id="interaction-mode">
                    <option value="target-to-reference">Target ‚Üí Reference</option>
                    <option value="reference-to-target">Reference ‚Üí Target</option>
                    <option value="random">Random Alternation</option>
                </select>
                <div class="mode-indicator" id="mode-indicator">Shown: Target, Answer: Reference</div>
            </div>
        </div>
        
        <!-- Error Display -->
        <div id="error-display" class="error-message" style="display: none;"></div>
        
        <!-- Concept Display with Hidden Answer -->
        <div class="concept-display-container">
            <div id="concept-content">
                <div class="loading" id="loading-indicator">
                    <div class="loading-spinner"></div>
                    <div>Loading language data...</div>
                </div>
                <div class="concept-main" id="concept-main" style="display: none;">
                    <div class="concept-icon" id="concept-icon">üö™</div>
                    <div class="concept-type" id="concept-type">Noun</div>
                    <div class="concept-word" id="concept-word">room</div>
                    <div class="concept-phonetic" id="concept-phonetic">/ruÀêm/</div>
                    <div class="conjugation-display" id="conjugation-display">
                        <!-- Conjugation tags will appear here when conjugating -->
                    </div>
                </div>
            </div>
            
            <div class="answer-sidebar">
                <div class="answer-label">Answer</div>
                <div class="answer-hidden" id="answer-hidden">
                    <i class="fas fa-question-circle"></i> Will appear after your response
                </div>
                <div class="answer-word" id="answer-word"></div>
                <div class="answer-phonetic" id="answer-phonetic"></div>
                <div class="answer-feedback" id="answer-feedback"></div>
            </div>
        </div>
        
        <!-- Action Section -->
        <div class="action-section">
            <div class="guess-section">
                <input type="text" class="guess-input" id="guess-input" placeholder="Type your guess here..." disabled>
                <button class="send-btn" id="send-btn" disabled>Send</button>
            </div>
            <button class="action-btn tell-btn" id="tell-btn" disabled>
                <i class="fas fa-eye"></i> Tell the Answer
            </button>
            <button class="action-btn next-btn" id="next-btn" disabled>
                <i class="fas fa-arrow-right"></i> OK, Next...
            </button>
        </div>
        
        <!-- Conjugate Button -->
        <button class="conjugate-btn" id="conjugate-btn" style="display: none;" disabled>Conjugate Verb</button>
        
        <!-- Footer -->
        <div class="footer">
            <p>IDIOMATOR ‚Ä¢ Language Learning Tool ‚Ä¢ Practice words and conjugations</p>
        </div>
    </div>

    <script>
        // Configuration
        const CONFIG = {
            answerDisplayTime: 1500,
            answerCheckTime: 1000
        };

        // Language data
        let languageData = {
            en: [],
            es: [],
            ka: []
        };
        
        let concepts = [];

        // App state
        let state = {
            targetLanguage: 'en',
            referenceLanguage: 'es',
            interactionMode: 'target-to-reference',
            currentConceptIndex: 0,
            correctAnswers: 0,
            totalAnswers: 0,
            isConjugating: false,
            currentVerb: null,
            currentTense: null,
            currentPerson: null,
            conjugationTenses: ['present', 'past'],
            conjugationPersons: ['1sg', '2sg', '3sg', '1pl', '2pl', '3pl'],
            answerShown: false,
            awaitingNext: false,
            dataLoaded: false,
            usingFallbackData: false
        };

        // DOM Elements
        const targetLanguageSelect = document.getElementById('target-language');
        const referenceLanguageSelect = document.getElementById('reference-language');
        const interactionModeSelect = document.getElementById('interaction-mode');
        const modeIndicator = document.getElementById('mode-indicator');
        const conceptMain = document.getElementById('concept-main');
        const loadingIndicator = document.getElementById('loading-indicator');
        const errorDisplay = document.getElementById('error-display');
        const conceptIcon = document.getElementById('concept-icon');
        const conceptType = document.getElementById('concept-type');
        const conceptWord = document.getElementById('concept-word');
        const conceptPhonetic = document.getElementById('concept-phonetic');
        const conjugationDisplay = document.getElementById('conjugation-display');
        const answerHidden = document.getElementById('answer-hidden');
        const answerWord = document.getElementById('answer-word');
        const answerPhonetic = document.getElementById('answer-phonetic');
        const answerFeedback = document.getElementById('answer-feedback');
        const conjugateBtn = document.getElementById('conjugate-btn');
        const guessInput = document.getElementById('guess-input');
        const sendBtn = document.getElementById('send-btn');
        const tellBtn = document.getElementById('tell-btn');
        const nextBtn = document.getElementById('next-btn');
        const correctCount = document.getElementById('correct-count');
        const totalCount = document.getElementById('total-count');
        const accuracy = document.getElementById('accuracy');

        // Fallback data in case external files fail
        const fallbackConcepts = [
            { type: 'noun', icon: 'üö™' },
            { type: 'verb', icon: 'üèÉ' },
            { type: 'adjective', icon: 'üîµ' },
            { type: 'adverb', icon: '‚ö°' },
            { type: 'noun', icon: 'üìö' },
            { type: 'verb', icon: 'üó£Ô∏è' },
            { type: 'adjective', icon: 'üî¥' },
            { type: 'noun', icon: 'üçé' },
            { type: 'verb', icon: 'üö∂' },
            { type: 'adjective', icon: 'üü¢' }
        ];

        const fallbackLanguageData = {
            en: [
                { word: 'door', phonetic: '/d…îÀêr/' },
                { word: 'run', phonetic: '/r ån/', forms: { present: { '1sg': 'run', '2sg': 'run', '3sg': 'runs', '1pl': 'run', '2pl': 'run', '3pl': 'run' }, past: { '1sg': 'ran', '2sg': 'ran', '3sg': 'ran', '1pl': 'ran', '2pl': 'ran', '3pl': 'ran' } } },
                { word: 'blue', phonetic: '/bluÀê/' },
                { word: 'quickly', phonetic: '/Ààkw…™kli/' },
                { word: 'book', phonetic: '/b äk/' },
                { word: 'speak', phonetic: '/spiÀêk/', forms: { present: { '1sg': 'speak', '2sg': 'speak', '3sg': 'speaks', '1pl': 'speak', '2pl': 'speak', '3pl': 'speak' }, past: { '1sg': 'spoke', '2sg': 'spoke', '3sg': 'spoke', '1pl': 'spoke', '2pl': 'spoke', '3pl': 'spoke' } } },
                { word: 'red', phonetic: '/red/' },
                { word: 'apple', phonetic: '/Àà√¶p.…ôl/' },
                { word: 'walk', phonetic: '/w…îÀêk/', forms: { present: { '1sg': 'walk', '2sg': 'walk', '3sg': 'walks', '1pl': 'walk', '2pl': 'walk', '3pl': 'walk' }, past: { '1sg': 'walked', '2sg': 'walked', '3sg': 'walked', '1pl': 'walked', '2pl': 'walked', '3pl': 'walked' } } },
                { word: 'green', phonetic: '/…°riÀên/' }
            ],
            es: [
                { word: 'puerta', phonetic: '/Ààpwe…æ.ta/' },
                { word: 'correr', phonetic: '/koÀàre…æ/', forms: { present: { '1sg': 'corro', '2sg': 'corres', '3sg': 'corre', '1pl': 'corremos', '2pl': 'corr√©is', '3pl': 'corren' }, past: { '1sg': 'corr√≠', '2sg': 'corriste', '3sg': 'corri√≥', '1pl': 'corrimos', '2pl': 'corristeis', '3pl': 'corrieron' } } },
                { word: 'azul', phonetic: '/aÀàŒ∏ul/' },
                { word: 'r√°pidamente', phonetic: '/ÀårapidaÀàmente/' },
                { word: 'libro', phonetic: '/Ààli.b…æo/' },
                { word: 'hablar', phonetic: '/aÀàblar/', forms: { present: { '1sg': 'hablo', '2sg': 'hablas', '3sg': 'habla', '1pl': 'hablamos', '2pl': 'habl√°is', '3pl': 'hablan' }, past: { '1sg': 'habl√©', '2sg': 'hablaste', '3sg': 'habl√≥', '1pl': 'hablamos', '2pl': 'hablasteis', '3pl': 'hablaron' } } },
                { word: 'rojo', phonetic: '/Ààro.xo/' },
                { word: 'manzana', phonetic: '/manÀàŒ∏ana/' },
                { word: 'caminar', phonetic: '/kamiÀànar/', forms: { present: { '1sg': 'camino', '2sg': 'caminas', '3sg': 'camina', '1pl': 'caminamos', '2pl': 'camin√°is', '3pl': 'caminan' }, past: { '1sg': 'camin√©', '2sg': 'caminaste', '3sg': 'camin√≥', '1pl': 'caminamos', '2pl': 'caminasteis', '3pl': 'caminaron' } } },
                { word: 'verde', phonetic: '/Ààbe…æ.√∞e/' }
            ],
            ka: [
                { word: '·Éô·Éê·É†·Éò', phonetic: '/k º…ë…æi/' },
                { word: '·É°·Éò·É†·Éë·Éò·Éö·Éò', phonetic: '/sirbili/' },
                { word: '·Éö·É£·É†·ÉØ·Éò', phonetic: '/lurdÕ° íi/' },
                { word: '·É°·É¨·É†·Éê·É§·Éê·Éì', phonetic: '/sts º…æ…ëp ∞…ëd/' },
                { word: '·É¨·Éò·Éí·Éú·Éò', phonetic: '/ts ºi…°ni/' },
                { word: '·Éö·Éê·Éû·Éê·É†·Éê·Éô·Éò', phonetic: '/l…ëp º…ë…æ…ëk ºi/' },
                { word: '·É¨·Éò·Éó·Éî·Éö·Éò', phonetic: '/ts ºit ∞eli/' },
                { word: '·Éï·Éê·É®·Éö·Éò', phonetic: '/v…ë Éli/' },
                { word: '·É°·Éï·Éö·Éê', phonetic: '/svl…ë/' },
                { word: '·Éõ·É¨·Éï·Éê·Éú·Éî', phonetic: '/mts ºv…ëne/' }
            ]
        };

        // Initialize the app
        async function init() {
            // Set up event listeners
            targetLanguageSelect.addEventListener('change', handleLanguageChange);
            referenceLanguageSelect.addEventListener('change', handleLanguageChange);
            interactionModeSelect.addEventListener('change', handleInteractionModeChange);
            
            sendBtn.addEventListener('click', handleSendGuess);
            guessInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') handleSendGuess();
            });
            
            tellBtn.addEventListener('click', handleTellAnswer);
            nextBtn.addEventListener('click', handleNext);
            conjugateBtn.addEventListener('click', toggleConjugation);
            
            // Show loading indicator
            loadingIndicator.style.display = 'flex';
            conceptMain.style.display = 'none';
            
            // Set initial language selections
            targetLanguageSelect.value = state.targetLanguage;
            referenceLanguageSelect.value = state.referenceLanguage;
            interactionModeSelect.value = state.interactionMode;
            
            // Try to load external data
            try {
                await loadAllData();
                state.dataLoaded = true;
                console.log('External data loaded successfully');
            } catch (error) {
                console.error('Failed to load external data, using fallback:', error);
                showError('Using fallback data. External files could not be loaded.');
                useFallbackData();
            }
            
            // Load initial concept
            if (state.dataLoaded) {
                loadNewConcept();
                updateStats();
                updateModeIndicator();
            }
        }

        // Load all data from external files
        async function loadAllData() {
            try {
                // Load concepts data
                const conceptsResponse = await fetch('data/concept.json');
                if (!conceptsResponse.ok) {
                    throw new Error(`Failed to load concepts: ${conceptsResponse.status}`);
                }
                
                // Try to parse concepts
                const conceptsText = await conceptsResponse.text();
                let parsedConcepts;
                
                try {
                    parsedConcepts = JSON.parse(conceptsText);
                    console.log('Concepts parsed as JSON:', parsedConcepts);
                } catch (e) {
                    // If not valid JSON, try other formats
                    console.log('Concepts file is not JSON, trying other formats...');
                    
                    // Try NDJSON (newline-delimited JSON)
                    const lines = conceptsText.split('\n').filter(line => line.trim() !== '');
                    parsedConcepts = lines.map(line => {
                        try {
                            return JSON.parse(line);
                        } catch (parseError) {
                            console.error('Failed to parse line:', line);
                            return null;
                        }
                    }).filter(item => item !== null);
                    
                    console.log('Concepts parsed as NDJSON:', parsedConcepts);
                }
                
                if (!parsedConcepts || parsedConcepts.length === 0) {
                    throw new Error('No valid concepts found in file');
                }
                
                concepts = parsedConcepts;
                console.log(`Loaded ${concepts.length} concepts`);
                
                // Load language data
                const languages = ['en', 'es', 'ka'];
                const loadPromises = languages.map(async (lang) => {
                    try {
                        const response = await fetch(`languages/${lang}.json`);
                        if (!response.ok) {
                            throw new Error(`Failed to load ${lang}.json: ${response.status}`);
                        }
                        
                        const text = await response.text();
                        let words = [];
                        
                        // Try to parse as JSON
                        try {
                            const parsed = JSON.parse(text);
                            if (Array.isArray(parsed)) {
                                words = parsed;
                            } else if (parsed && typeof parsed === 'object') {
                                // If it's an object with words property
                                if (parsed.words && Array.isArray(parsed.words)) {
                                    words = parsed.words;
                                } else {
                                    // Convert object to array
                                    words = Object.values(parsed);
                                }
                            }
                        } catch (e) {
                            // Not JSON, try NDJSON
                            const lines = text.split('\n').filter(line => line.trim() !== '');
                            words = lines.map(line => {
                                try {
                                    return JSON.parse(line);
                                } catch (parseError) {
                                    return null;
                                }
                            }).filter(item => item !== null);
                        }
                        
                        if (words.length === 0) {
                            throw new Error(`No valid data in ${lang}.json`);
                        }
                        
                        languageData[lang] = words;
                        console.log(`Loaded ${words.length} words for ${lang}`);
                        return true;
                    } catch (error) {
                        console.error(`Error loading ${lang}:`, error);
                        return false;
                    }
                });
                
                const results = await Promise.all(loadPromises);
                const successfulLoads = results.filter(result => result === true).length;
                
                if (successfulLoads === 0) {
                    throw new Error('Could not load any language data');
                }
                
                state.dataLoaded = true;
                state.usingFallbackData = false;
                
            } catch (error) {
                console.error('Error loading data:', error);
                throw error;
            }
        }

        // Use fallback data
        function useFallbackData() {
            concepts = fallbackConcepts;
            languageData = fallbackLanguageData;
            state.dataLoaded = true;
            state.usingFallbackData = true;
        }

        // Show error message
        function showError(message) {
            errorDisplay.textContent = message;
            errorDisplay.style.display = 'block';
            
            // Hide error after 5 seconds
            setTimeout(() => {
                errorDisplay.style.display = 'none';
            }, 5000);
        }

        // Handle language change
        function handleLanguageChange() {
            if (!state.dataLoaded) return;
            
            state.targetLanguage = targetLanguageSelect.value;
            state.referenceLanguage = referenceLanguageSelect.value;
            
            // Make sure languages are different
            if (state.targetLanguage === state.referenceLanguage) {
                if (state.targetLanguage === 'en') {
                    state.referenceLanguage = 'es';
                    referenceLanguageSelect.value = 'es';
                } else {
                    state.referenceLanguage = 'en';
                    referenceLanguageSelect.value = 'en';
                }
            }
            
            loadNewConcept();
            updateModeIndicator();
        }

        // Handle interaction mode change
        function handleInteractionModeChange() {
            if (!state.dataLoaded) return;
            
            state.interactionMode = interactionModeSelect.value;
            loadNewConcept();
            updateModeIndicator();
        }

        // Update mode indicator text
        function updateModeIndicator() {
            let indicatorText = '';
            
            switch(state.interactionMode) {
                case 'target-to-reference':
                    indicatorText = 'Shown: Target, Answer: Reference';
                    break;
                case 'reference-to-target':
                    indicatorText = 'Shown: Reference, Answer: Target';
                    break;
                case 'random':
                    indicatorText = 'Randomly alternating direction';
                    break;
            }
            
            modeIndicator.textContent = indicatorText;
        }

        // Load a new concept
        function loadNewConcept() {
            if (!state.dataLoaded || concepts.length === 0) {
                console.error('No concepts available');
                return;
            }
            
            // Hide loading indicator and show concept
            loadingIndicator.style.display = 'none';
            conceptMain.style.display = 'flex';
            
            // Enable all buttons and inputs
            enableInterface(true);
            
            // Reset state
            state.answerShown = false;
            state.awaitingNext = false;
            
            // Hide answer and show placeholder
            answerHidden.style.display = 'flex';
            answerWord.style.display = 'none';
            answerPhonetic.style.display = 'none';
            answerFeedback.textContent = '';
            answerFeedback.className = 'answer-feedback';
            
            // Clear conjugation display
            conjugationDisplay.innerHTML = '';
            
            // Get a random concept index
            state.currentConceptIndex = Math.floor(Math.random() * concepts.length);
            const concept = concepts[state.currentConceptIndex];
            
            // Debug logging
            console.log('Current concept:', concept);
            console.log('Concept index:', state.currentConceptIndex);
            
            // Update concept display
            if (concept && concept.icon) {
                // Handle different icon formats
                if (concept.icon.startsWith('<i')) {
                    conceptIcon.innerHTML = concept.icon;
                } else if (concept.icon.startsWith('fa-')) {
                    conceptIcon.innerHTML = `<i class="fas ${concept.icon}"></i>`;
                } else {
                    conceptIcon.innerHTML = concept.icon;
                }
            } else {
                conceptIcon.innerHTML = '‚ùì';
            }
            
            conceptType.textContent = concept ? concept.type : 'Unknown';
            
            // Get words for current concept
            const targetWord = getWordForLanguage(state.targetLanguage, state.currentConceptIndex);
            const referenceWord = getWordForLanguage(state.referenceLanguage, state.currentConceptIndex);
            
            // Debug logging
            console.log('Target word:', targetWord);
            console.log('Reference word:', referenceWord);
            
            // Determine display based on interaction mode
            let displayWord, displayPhonetic, answerWordText, answerPhoneticText, currentDirection;
            
            if (state.interactionMode === 'target-to-reference') {
                displayWord = targetWord.word;
                displayPhonetic = targetWord.phonetic;
                answerWordText = referenceWord.word;
                answerPhoneticText = referenceWord.phonetic;
                currentDirection = 'target-to-reference';
            } else if (state.interactionMode === 'reference-to-target') {
                displayWord = referenceWord.word;
                displayPhonetic = referenceWord.phonetic;
                answerWordText = targetWord.word;
                answerPhoneticText = targetWord.phonetic;
                currentDirection = 'reference-to-target';
            } else {
                // Random mode
                if (Math.random() > 0.5) {
                    displayWord = targetWord.word;
                    displayPhonetic = targetWord.phonetic;
                    answerWordText = referenceWord.word;
                    answerPhoneticText = referenceWord.phonetic;
                    currentDirection = 'target-to-reference';
                } else {
                    displayWord = referenceWord.word;
                    displayPhonetic = referenceWord.phonetic;
                    answerWordText = targetWord.word;
                    answerPhoneticText = targetWord.phonetic;
                    currentDirection = 'reference-to-target';
                }
                
                // Update mode indicator temporarily for random mode
                const indicatorText = currentDirection === 'target-to-reference' 
                    ? 'Current: Target ‚Üí Reference' 
                    : 'Current: Reference ‚Üí Target';
                modeIndicator.textContent = indicatorText;
            }
            
            // Update display
            conceptWord.textContent = displayWord;
            conceptPhonetic.textContent = displayPhonetic || '';
            answerWord.textContent = answerWordText;
            answerPhonetic.textContent = answerPhoneticText || '';
            
            // Clear guess input
            guessInput.value = '';
            
            // Show/hide conjugate button based on word type
            if (concept && concept.type === 'verb' && targetWord.forms) {
                conjugateBtn.style.display = 'block';
                conjugateBtn.textContent = 'Conjugate Verb';
                conjugateBtn.classList.remove('conjugating');
                conjugateBtn.disabled = false;
                state.currentVerb = targetWord;
            } else {
                conjugateBtn.style.display = 'none';
                state.currentVerb = null;
            }
            
            // Store the correct answer for checking
            state.currentCorrectAnswer = answerWordText;
            state.currentDirection = currentDirection;
            
            // If we're conjugating, set up a new conjugation prompt
            if (state.isConjugating && state.currentVerb) {
                setupConjugationPrompt();
            }
        }

        // Get word for a specific language and concept index
        function getWordForLanguage(language, conceptIndex) {
            // Make sure we have data for this language
            if (!languageData[language]) {
                console.error(`No data for language: ${language}`);
                return {
                    word: `[No ${language.toUpperCase()} data]`,
                    phonetic: '/?/'
                };
            }
            
            // Check if we have enough words in this language
            if (conceptIndex >= languageData[language].length) {
                console.warn(`Concept index ${conceptIndex} out of bounds for ${language} (length: ${languageData[language].length})`);
                
                // Use modulo to wrap around if index is too high
                const wrappedIndex = conceptIndex % languageData[language].length;
                return languageData[language][wrappedIndex] || {
                    word: `[${language.toUpperCase()} word ${wrappedIndex}]`,
                    phonetic: '/?/'
                };
            }
            
            return languageData[language][conceptIndex] || {
                word: `[${language.toUpperCase()} word ${conceptIndex}]`,
                phonetic: '/?/'
            };
        }

        // Enable/disable interface elements
        function enableInterface(enabled) {
            guessInput.disabled = !enabled;
            sendBtn.disabled = !enabled;
            tellBtn.disabled = !enabled;
            nextBtn.disabled = !enabled;
            if (!enabled) {
                conjugateBtn.disabled = true;
            }
        }

        // Show the answer with feedback
        function showAnswer(isCorrect, message) {
            state.answerShown = true;
            answerHidden.style.display = 'none';
            answerWord.style.display = 'flex';
            answerPhonetic.style.display = 'block';
            
            if (message) {
                answerFeedback.textContent = message;
                answerFeedback.className = isCorrect ? 'answer-feedback correct' : 'answer-feedback incorrect';
            }
            
            state.awaitingNext = true;
        }

        // Handle send guess
        function handleSendGuess() {
            if (state.answerShown || state.awaitingNext || !state.dataLoaded) return;
            
            const userGuess = guessInput.value.trim().toLowerCase();
            
            // Use the correct conjugation if we're conjugating, otherwise use the regular answer
            const correctAnswer = state.isConjugating && state.currentCorrectConjugation 
                ? state.currentCorrectConjugation.toLowerCase()
                : state.currentCorrectAnswer.toLowerCase();
            
            state.totalAnswers++;
            
            if (userGuess === correctAnswer) {
                state.correctAnswers++;
                showAnswer(true, 'Correct!');
            } else {
                showAnswer(false, 'Incorrect.');
            }
            
            updateStats();
        }

        // Handle tell answer
        function handleTellAnswer() {
            if (state.answerShown || state.awaitingNext || !state.dataLoaded) return;
            
            state.totalAnswers++;
            showAnswer(false, 'Answer revealed.');
            updateStats();
        }

        // Handle next
        function handleNext() {
            if (!state.dataLoaded) return;
            
            if (!state.answerShown) {
                // User pressed Next without seeing the answer first
                state.correctAnswers++;
                state.totalAnswers++;
                showAnswer(true, 'Counted as correct!');
                updateStats();
                
                // Wait before loading next concept or conjugation
                if (state.isConjugating) {
                    setTimeout(() => {
                        if (state.isConjugating && state.currentVerb) {
                            setupConjugationPrompt();
                        } else {
                            loadNewConcept();
                        }
                    }, CONFIG.answerDisplayTime);
                } else {
                    setTimeout(loadNewConcept, CONFIG.answerDisplayTime);
                }
            } else {
                // Answer was already shown
                if (state.isConjugating) {
                    setupConjugationPrompt();
                } else {
                    loadNewConcept();
                }
            }
        }

        // Update statistics
        function updateStats() {
            correctCount.textContent = state.correctAnswers;
            totalCount.textContent = state.totalAnswers;
            
            const accuracyPercent = state.totalAnswers > 0 
                ? Math.round((state.correctAnswers / state.totalAnswers) * 100) 
                : 0;
            accuracy.textContent = `${accuracyPercent}%`;
        }

        // Toggle conjugation practice
        function toggleConjugation() {
            if (!state.dataLoaded) return;
            
            if (!state.isConjugating) {
                // Start conjugation
                state.isConjugating = true;
                conjugateBtn.textContent = 'Stop Conjugation';
                conjugateBtn.classList.add('conjugating');
                
                // Setup first conjugation prompt
                setupConjugationPrompt();
            } else {
                // Stop conjugation
                state.isConjugating = false;
                conjugateBtn.textContent = 'Conjugate Verb';
                conjugateBtn.classList.remove('conjugating');
                
                // Clear conjugation display
                conjugationDisplay.innerHTML = '';
                
                // Load a new regular concept
                loadNewConcept();
            }
        }

        // Setup conjugation prompt
        function setupConjugationPrompt() {
            if (!state.currentVerb || !state.currentVerb.forms) return;
            
            // Get random tense and person
            const tenseIndex = Math.floor(Math.random() * state.conjugationTenses.length);
            const personIndex = Math.floor(Math.random() * state.conjugationPersons.length);
            
            state.currentTense = state.conjugationTenses[tenseIndex];
            state.currentPerson = state.conjugationPersons[personIndex];
            
            // Get correct answer
            if (state.currentPerson === '*' || !state.currentVerb.forms[state.currentTense][state.currentPerson]) {
                state.currentCorrectConjugation = state.currentVerb.forms[state.currentTense]['*'] || 
                    state.currentVerb.word;
            } else {
                state.currentCorrectConjugation = state.currentVerb.forms[state.currentTense][state.currentPerson];
            }
            
            // Update answer display for conjugation (but keep hidden)
            answerWord.textContent = state.currentCorrectConjugation;
            answerPhonetic.textContent = '';
            
            // Update conjugation display with button-like tags
            conjugationDisplay.innerHTML = '';
            
            const tenseDisplay = state.currentTense === 'present' ? 'Present' : 'Past';
            const personDisplay = getPersonDisplay(state.currentPerson);
            
            // Create tense tag
            const tenseTag = document.createElement('span');
            tenseTag.className = 'conjugation-tag';
            tenseTag.textContent = tenseDisplay;
            conjugationDisplay.appendChild(tenseTag);
            
            // Create person tag
            const personTag = document.createElement('span');
            personTag.className = 'conjugation-tag';
            personTag.textContent = personDisplay;
            conjugationDisplay.appendChild(personTag);
            
            // Reset answer shown state
            state.answerShown = false;
            state.awaitingNext = false;
            
            // Hide answer and show placeholder
            answerHidden.style.display = 'flex';
            answerWord.style.display = 'none';
            answerPhonetic.style.display = 'none';
            answerFeedback.textContent = '';
            answerFeedback.className = 'answer-feedback';
            
            // Clear guess input
            guessInput.value = '';
        }

        // Get display text for person
        function getPersonDisplay(personCode) {
            const personMap = {
                '1sg': '1st singular',
                '2sg': '2nd singular',
                '3sg': '3rd singular',
                '1pl': '1st plural',
                '2pl': '2nd plural',
                '3pl': '3rd plural',
                '*': 'generic'
            };
            return personMap[personCode] || personCode;
        }

        // Initialize the app when page loads
        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>